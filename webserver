#!/usr/bin/env node


// Copyright 2020
// Sleepless Software Inc.
// All Rights Reserved
// sleepless.com

const L = require( "log5" ).mkLog( "webserver: " )( 4 );

const argv = process.argv;
if( argv.length < 3 ) {
	L.E( "Usage: webserver <create/run> <project_name/port> <dir>" );
	L.E( "For example: webserver create my_app");
	L.E( "For example: webserver create ~/d/another_app");
	L.E( "For example: webserver run 3000 my_app");
	L.E( "For example: webserver run 3000 ~/d/another_app");
	process.exit( 1 );
}

let act = argv[ 2 ] || null;

if( ! act ) { process.exit(-1); }

if( act == "create" ) {
	const fs = require( "fs" );
	const path = require( "path" );
	const { exec } = require( "child_process" );
	let PATH = argv[3];
	let old_path = PATH;
	// use local path or absolute path
	PATH = path.resolve( PATH );

	if( !fs.existsSync(PATH) ) {
		fs.mkdir( PATH, { recursive: true }, ( err, p ) => {
			if( err ) { return L.E( err ); }
			L.I( `made directory ${p}` );
			// To copy a folder or file  
			exec(`cp -r ${__dirname}/template/* ${PATH}; cd ${PATH}; npm i;`, err => {
				if( err ) { L.E( err ); process.exit(-1); }
				L.I(`webserver run 3000 ${old_path}`);
				process.exit(0);
			});
		})
	} else {
		console.error( `${PATH} already exists. Exiting...`);
		process.exit(-1);
	}

}

if( act == "run" ) {
	let PORT = argv[3] || 12345;
	let PATH = argv[4] || "./";
	if( PATH[ PATH.length - 1 ] != "/" )  { PATH += "/"; }

	let WATCH = argv[5];

	var http = require('http')
	var parseUrl = require('parseurl')
	var send = require('send')

	let path = require("path");
	let { spawn, exec } = require("child_process");
	let p = path.resolve(PATH);
	
	var server = http.createServer(function onRequest (req, res ) {
		let data = '';
		req.on('data', chunk => {
			data += chunk;
		})
		req.on('end', () => {
			L.D( req.method + " " + req.url );
			req.body = data;
			dispatch( p, req, res )
		})
	});
	
	// sandbox app
	exec(`cd ${p};`, err => {
		if( err ) { L.E( err ); return; }

		if( WATCH ) {
			// sandbox watch
			exec(`chmod +x ./watch; ./watch &`, err => {
				if( err ) { L.E( err ); return; }
			});
		}
		server.listen( PORT, function() { 
			L.I( "Copyright " + (new Date() . getFullYear()) + " Sleepless Software Inc.  All Rights Reserved - sleepless.com" );
			L.I( "Listening on port " + PORT + ", serving from directory \"" + p + "\"");
		});
	})

	const serve_static = require("serve-static");

	let dispatch = function( root, req, res ) {
		let mod = mod_load( root );
		if( mod ) { 
			L.D("root module loaded "+root);
		   	mod( req, res, (r1, r2) => {
				if( r1 && r2 ) {
					send(r1, parseUrl(r1).pathname, { root: root }).pipe(r2);
				}
			});
		} else {
			send(req, parseUrl(req).pathname, { root: root }) .pipe(res);
		}
	}

	// Tries to load path (must be a dir) as an NPM module. Returns the module or null.
	globalThis.mod_load = function( path, n ) {
		let mod = null;
		const p = require("path");
		try {
			// use local path or absolute path
			if( path && ! p.isAbsolute(path) ) { path = p.join(__dirname, path); }
			mod = require( path );
			L.D( "mod loaded: " +  path );
		} catch( err ) {
			// If this e.code is present, it means the module just couldn't be loaded for some reason.
			// But it seems not to be there if the module loaded but got a syntax error or something,
			// which I DO want to see, so I differentiate between those two cases here.
			if( err.code == "MODULE_NOT_FOUND") {
				L.D( "module not found: " + path );
				// L.W(err.stack);	
			}
			else {
				//L.W( "module present but fails to load" );
				L.E( err.stack );
			}
		}

		return mod;
	}
}
