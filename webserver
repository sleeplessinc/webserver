#!/usr/bin/env node


// Copyright 2020
// Sleepless Software Inc.
// All Rights Reserved
// sleepless.com

const L = require( "log5" ).mkLog( "webserver: " )( 5 );

const argv = process.argv;
if( argv.length < 3 ) {
	L.E( "Usage: webserver <create/run> <project_name/port> <dir>" );
	L.E( "For example: webserver create my_app");
	L.E( "For example: webserver create ~/d/another_app");
	L.E( "For example: webserver run 3000 my_app");
	L.E( "For example: webserver run 3000 ~/d/another_app");
	process.exit( 1 );
}

let act = argv[ 2 ] || null;

if( ! act ) return;

if( act == "create" ) {
	const fs = require( "fs" );
	const path = require( "path" );
	let PATH = argv[3];
	let old_path = PATH;
	// use local path or absolute path
	if( PATH && ! path.isAbsolute(PATH) ) { PATH = path.join(__dirname, PATH); }

	if( !fs.existsSync(PATH) ) {
		fs.mkdir( PATH, { recursive: true }, ( err, p ) => {
			if( err ) { return console.error( err ); }
			L.V( `made directory ${p}` );
			// To copy a folder or file  
			copyFolderRecursiveSync( path.join(__dirname, "template/"), PATH);
			L.V(`webserver run 3000 ${old_path}`);
		})
		return;
	}

	console.error( `${PATH} already exists. Exiting...`);
	return;

	function copyFileSync( source, target ) {
		var targetFile = target;

		// If target is a directory, a new file with the same name will be created
		if ( fs.existsSync( target ) ) {
			if ( fs.lstatSync( target ).isDirectory() ) {
				targetFile = path.join( target, path.basename( source ) );
			}
		}

		fs.writeFileSync(targetFile, fs.readFileSync(source));
	}

	function copyFolderRecursiveSync( source, target ) {
		var files = [];

		// Check if folder needs to be created or integrated
		var targetFolder = target; 
		if ( !fs.existsSync( targetFolder ) ) {
			fs.mkdirSync( targetFolder );
		}

		// Copy
		if ( fs.lstatSync( source ).isDirectory() ) {
			files = fs.readdirSync( source );
			files.forEach( function ( file ) {
				var curSource = path.join( source, file );
				if ( fs.lstatSync( curSource ).isDirectory() ) {
					copyFolderRecursiveSync( curSource, targetFolder );
				} else {
					copyFileSync( curSource, targetFolder );
				}
			} );
		}
	}
}

if( act == "run" ) {
	let PORT = argv[3] || 12345;
	let PATH = argv[4] || "./";
	if( PATH[ PATH.length - 1 ] != "/" )  { PATH += "/"; }

	let WATCH = argv[5];

	var http = require('http')
	var parseUrl = require('parseurl')
	var send = require('send')
	
	var server = http.createServer(function onRequest (req, res ) {
		L.V( req.method + " " + req.url );
		dispatch( PATH, req, res )
	});
	
	if( WATCH ) {
		const path = require( "path" );
		const { spawn } = require("child_process");
		const e = spawn(`./${PATH}/watch`);

		e.stdout.on("data", data => {
			L.V(`stdout: ${data}`);
		});

		e.stderr.on("data", data => {
			L.V(`stderr: ${data}`);
		});

		e.on('error', (error) => {
			L.E(`error: ${error}`);
		});

		e.on("close", code => {
			L.E(`child process exited with code ${code}`);
		});
	}
	server.listen( PORT, function() { 
		L.I( "Copyright " + (new Date() . getFullYear()) + " Sleepless Software Inc.  All Rights Reserved - sleepless.com" );
		L.I( "Listening on port " + PORT + ", serving from directory \"" + PATH + "\"");
	});

	const serve_static = require("serve-static");

	let dispatch = function( root, req, res ) {
		let mod = mod_load( root );
		if( mod ) { 
			L.D("root module loaded "+root);
		   	mod( req, res, (r1, r2) => {
				if( r1 && r2 ) {
					send(r1, parseUrl(r1).pathname, { root: root }).pipe(r2);
				}
			});
		} else {
			send(req, parseUrl(req).pathname, { root: root }) .pipe(res);
		}
	}

	// Tries to load path (must be a dir) as an NPM module. Returns the module or null.
	let mod_load = function( path, n ) {
		let mod = null;
		const p = require("path");
		try {
			// use local path or absolute path
			if( path && ! p.isAbsolute(path) ) { path = p.join(__dirname, path); }
			mod = require( path );
			L.D( "mod loaded: " +  path );
		} catch( err ) {
			// If this e.code is present, it means the module just couldn't be loaded for some reason.
			// But it seems not to be there if the module loaded but got a syntax error or something,
			// which I DO want to see, so I differentiate between those two cases here.
			if( err.code == "MODULE_NOT_FOUND") {
				L.D( "module not found: " + path );
				// L.W(err.stack);	
			}
			else {
				//L.W( "module present but fails to load" );
				L.E( err.stack );
			}
		}

		return mod;
	}
}
